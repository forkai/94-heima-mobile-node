>| 姓名 | 意见或建议                                             |
>| ---- | ------------------------------------------------------ |
>| ***  | 今天的知识我已经懵了 我全程都在听课 可我不知道会了些啥 |

>昨天讲了什么 ?

小智同学 开发完毕 =>  websocket 发消息 接收消息

原生的webscoket  =>  打开连接 / 关闭连接 / 发送消息 /接收消息

var  socket = new WebSocket(地址)  // 初始化websocket连接

socket .onopen= function(){}  //  此函数 会在连接成功之后执行

socket.send  // 发送消息

socket.onmessage = function(){} // 接收消息



>除了原生的websocket,还讲了什么替代性方案 替代原生的websocket

socket.io  => 

原生的websocket => 原生js

socket.io  => 类似jq , 对原来的业务进行了封装

socket.io 如何打开连接  =>    import  io  from 'socket.io '  var  abc = io(地址, 参数)

abc.on("connect" , function(){})  // 监听连接成功的事件

// 接收消息 

abc.on('message')  //  小智同学 接收消息时message, message是消息类型

到了别的企业.别的公司 可能就不是message了

abc.on('msg')

>在socket.io框架中 只有 connect(连接成功)   和 disconnect(关闭成功) 事件名称是固定的

组件缓存

>场景:  当我们 进入了组件A , 离开组件A, 组件A就会被销毁,再次回到组件A, 组件A就会被重新创建

导致,我们进入页面读取内容,突然有别的事件, 再回来之后,之前的记忆全都没了

>我们需要保持组件的状态,离开的时候什么样子 ,回来的时候还是什么样子

组件缓存  => 保持组件状态的一个机制  => 组件销毁 => 创建 就会重置状态 => 不能让组件销毁, 保持状态

如何不让一个组件销毁?

>keep-alive 是一个 vue框架内置的组件, template   都不生成任何实质标签

只要用keep-alive包裹的组件 , 就不会被销毁, 组件实例并不会销毁,一直都在, 切换该组件的时候 ,组件就会被重新渲染  => 虚拟dom (并不是真正的dom 和原生dom一样,但是并没有挂载到页面上) => 重新挂载页面

>keep-alive包裹组件之后,组件就不会再销毁,如果不销毁的话,就没有钩子函数了
>
>当我们第一次进入组件的时候, created 会执行, 再次进入 就不会执行了

keep-alive 专门提供了两个钩子函数 用来鉴别 缓存的组件回到该页面

>activated  =>  
>
>deactivated   => 睡眠事件 => 缓存组件进入睡眠状态的时候执行

>this.$nextTick 是为了解决什么问题出现的?

vue  => 响应式数据    this.name = '张三'  => 视图并不会立刻发生变化 => 异步

this.$nextTick(fucntion(){    })

// 该函数执行时 保证了 上一次数据更新之后 页面已经完成了渲染

this.name = '张三' this.name = '李四'  this.name = '王五'

this.$nextTick(function(){ 打印dom中的name    })

>组件缓存   
>
>二级路由缓存
>
>一级路由缓存 => 一级路由的组件里 有二级路由容器
>
>如果继续用keep-alive包裹整个的一级路由容器 就会导致所有的一级路由组件被 缓存
>
>如果导致 所有组件缓存 => 预示着 所有的组件都不会被销毁 => 组件实例 内存 =>  浏览器内存
>
>=>  内存有泄漏的方向  => 内存空间不够, 内存泄漏
>
>为了不让所有组件缓存 =>  v-if  => 作用在 一级路由容器上  => 
>
>路由里面设置了一个**meta**属性 ,是路由元信息  => 配置路由的时候,可以给路由一些参数,参数放置在meta属性里面,  meta名字是固定的, 但是meta对象里面的内容可以随意定义
>
>```js
>   meta: {
>        isAlive: true // 是否缓存组件实例
>      }
>```
>
>isLive属性可以用作 判断当前路由是否需要缓存的依据
>
>isAlive true  => 表示该组件需要缓存
>
>isAlive false  => 不需要缓存
>
>```xml
>    <keep-alive>
>      <!-- 一级路由容器  将所有的一级路由组件 都进行了缓存-->
>       <!--
>         $route.meta.isAlive 如果为 true 就需要用keep-alive包裹 router-view
>         如果为false 就必须把router-view 放置在 keep-alive组件之外
>         v-if  条件渲染
>         -->
>         <!-- 如果为true  就包在里面 -->
>         <!-- 可以保证只有 layout组件进行缓存 -->
>      <router-view v-if="$route.meta.isAlive"  />
>    </keep-alive>
>    <!-- 如果为false就放在外面 -->
>      <router-view v-if="!$route.meta.isAlive"  />
>  </div>
>```
>
>